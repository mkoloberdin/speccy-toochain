/* z80tomf3 - converts a Z80 v2/v3 128k snapshot to Multiface 3 format.
 * by Russell Marks (mr216@gre.ac.uk)
 * public domain
 *
 * Z80 format from z80.doc (hope I don't have to register for that ;^) )
 * MF3 format from m3data.frm (as in m3conv.arc)
 *
 * You'll need to run this on a Real Computer as it uses a
 * 128k array for the RAM. If you insist on using MS-DOS, you'd
 * better compile it with djgpp.
 *
 * usage: z80tomf3 wibble.z80
 *
 * This will produce wibble and wibblec, which you then need to get
 * to your +3 somehow. I leave this step up to you. :-)
 * (I transfer them across a serial link, using QTERM under CP/M.)
 * Make sure that they are transferred as headerless files, as the
 * 'wibble' part already has the header in the file, and 'wibblec' must
 * be headerless.
 *
 * v1.0 - 95/2/19
 *
 * It writes uncompressed MF3 snaps only at the moment. I suppose you
 * could save the snapshot after loading it on the +3 to do the
 * compression. A bit unpleasant, but it works.
 *
 * It also only converts 128k snapshots. I didn't bother with 48k ones
 * as I wrote a little program for the +3 to read .SNA's from the serial
 * port and run them (getsnapx), which made supporting 48k snaps a bit
 * pointless.
 *
 * todo:
 * split up the evil pile that is main() into separate functions
 * add compression
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>

#define Z80_V2_HEADER_SIZE	55

/* the Z80 v2 header */
unsigned char z80hed[Z80_V2_HEADER_SIZE];

/* RAM in page number order; 0, 1, 2, ... 7 */
/* perhaps you'd better use djgpp to compile this on dos ;^) */
unsigned char specmem[128*1024];

#define PAGE_OFFSET(x) ((x)<<14)


/* both of these are the examples from m3data.frm */

unsigned char m3loader[]={
  0x50,0x4C,0x55,0x53,0x33,0x44,0x4F,0x53,
  0x1A,0x01,0x00,0x69,0x01,0x00,0x00,0x00,   /* PLUS3DOS...i.... */
  0xE9,0x00,0x01,0x00,0xE9,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   /* ................ */
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   /* ................ */
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   /* ................ */
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   /* ................ */
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   /* ................ */
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   /* ................ */
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xB5,   /* ................ */
  0x00,0x01,0x91,0x00,0xEA,0xF3,0x01,0x82,
  0x00,0x2A,0x53,0x5C,0x09,0x4E,0x23,0x46,   /* .........*S\.N#F */
  0x3E,0xC3,0x32,0x7F,0x5C,0xED,0x43,0x80,
  0x5C,0x01,0xFD,0x7F,0x3E,0x10,0xED,0x79,   /* >.2.\.C.\...>..y */
  0x3A,0x67,0x5B,0xF6,0x04,0x06,0x1F,0xED,
  0x79,0x3E,0xFE,0xCD,0x01,0x16,0xDB,0x3F,   /* :g[.....y>.....? */
  0x3A,0x00,0x00,0xFE,0xC3,0x28,0x10,0x01,
  0x74,0x00,0x2A,0x53,0x5C,0x09,0x06,0x0E,   /* :....(..t.*S\... */
  0x7E,0xD7,0x23,0x10,0xFB,0x18,0xE7,0xDB,
  0xBF,0x2A,0x53,0x5C,0xE5,0x01,0x74,0x00,   /* ~.#......*S\..t. */
  0x09,0x06,0x07,0x7E,0xD7,0x23,0x10,0xFB,
  0xE1,0x01,0xBC,0x00,0x09,0x06,0x07,0x7E,   /* ...~.#.........~ */
  0xD7,0x23,0x10,0xFB,0xDB,0x3F,0xC3,0x7F,
  0x5C,0x44,0x47,0x54,0x34,0x30,0x30,0x43,   /* .#...?..\DGT400C */
  0xFF,0x20,0xE2,0x98,0x16,0x14,0x0C,0x12,
  0x01,0x11,0x06,0x4E,0x4F,0x54,0x20,0x4F,   /* . .........NOT O */
  0x4E,0x21,0x71,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,   /* N!q............. */
  0x00,0x00,0xFF,0x00,0x0D,0x00,0x00,0x02,
  0x4F,0x00,0xE7,0xBC,0xA7,0x3A,0xD9,0xBC,   /* ........O....:.. */
  0xA7,0x3A,0xDA,0xBC,0xA7,0x3A,0xFD,0xB0,
  0x22,0x32,0x34,0x35,0x34,0x33,0x22,0x3A,   /* .:...:.."24543": */
  0xF5,0x22,0x16,0x14,0x09,0x12,0x01,0x11,
  0x06,0x4D,0x33,0x20,0x4C,0x4F,0x41,0x44,   /* .".......M3 LOAD */
  0x49,0x4E,0x47,0x22,0x3A,0xF9,0xC0,0x28,
  0xB0,0x22,0x32,0x35,0x36,0x22,0x2A,0xBE,   /* ING":..(."256"*. */
  0xB0,0x22,0x32,0x33,0x36,0x33,0x36,0x22,
  0x2B,0xBE,0xB0,0x22,0x32,0x33,0x36,0x33,   /* ."23636"+.."2363 */
  0x35,0x22,0x2B,0xB0,0x22,0x35,0x22,0x29,
  0x0D,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   /* 5"+."5")........ */
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00    /* ................ */
  };


unsigned char m3dathed[]={
  0xC0,0x03,0x44,0x47,0x54,0x34,0x30,0x30,
  0x43,0xFF,0x20,0x20,0x00,0x1B,0x00,0x40,   /* ..DGT400C.  ...@ */
  0xFF,0xFF,0x00,0x00,0xE8,0x5F,0xB3,0x60,
  0x00,0x00,0xE2,0x98,0x12,0x14,0xC2,0xF8,   /* ....._.`........ */
  0x00,0x00,0x00,0x00,0x00,0x1C,0xCC,0x11,
  0x44,0x47,0x54,0x34,0x30,0x30,0x20,0xFF,   /* ........DGT400 . */
  0x20,0x00,0xE9,0x00,0x01,0x00,0xE9,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   /*  ............... */
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0xFB,0xD8,0x3A,0x5C,0x00,0x00,   /* ............:\.. */
  0x21,0x15,0x9B,0x36,0x38,0x00,0x6D,0x7E,
  0x01,0x06,0xDA,0x21,0x10,0xFE,0x40,0x3F,   /* !..68.m~...!..@? */
  0x5B,0x97,0x10,0x01,0xA2,0x61,0x00,0xF5,
  0xDB,0xBF,0xF1,0xCD,0x54,0x60,0xF3,0xF5,   /* [....a......T`.. */
  0xDB,0x3F,0xF1,0xC9,0xDD,0xE9,0x21,0x6B,
  0x00,0xF3,0xF5,0xDB,0x3F,0xF1,0xE9,0xF5,   /* .?....!k....?... */
  0xDB,0xBF,0xF1,0xCD,0x5E,0x60,0x18,0xE6,
  0xDB,0xBF,0xFD,0xCB,0x01,0xAE,0xFD,0xCB,   /* ....^`.......... */
  0x01,0xDE,0xFD,0xCB,0x30,0xDE,0xFB,0x76,
  0xF3,0xFD,0xCB,0x01,0x6E,0x28,0xE9,0x11,   /* ....0..v....n(.. */
  0x22,0x00,0x21,0xC8,0x00,0xCD,0xB5,0x03,
  0xF3,0xDB,0x3F,0x3A,0x08,0x5C,0xC9,0xF5,   /* ".!.......?:.\.. */
  0xDB,0xBF,0xF1,0xD7,0x18,0xB8,0xDB,0xBF,
  0xED,0xB0,0x18,0xB2,0xDB,0xBF,0xCD,0xE5,   /* ................ */
  0x19,0x18,0xAB,0xDB,0xBF,0xCD,0x55,0x16,
  0x18,0xA4,0xDB,0xBF,0x4E,0x18,0x9F,0x2A,   /* ......U.....N..* */
  0x2E,0x2A,0xFF,0xC5,0x00,0x00,0x37,0xED,
  0xCB,0xDB,0x02,0x4D,0x00,0xA6,0x57,0x5A,   /* .*....7....M..WZ */
  0x00,0xA5,0x57,0xDB,0x02,0x4D,0x00,0xB1,
  0x33,0x83,0x00,0x00,0x7E,0x9B,0x36,0x06,   /* ..W..M..3...~.6. */
  0x03,0xDB,0x02,0x73,0x38,0x00,0x00,0x4D,
  0x00,0xB4,0x49,0x00,0x00,0x86,0xFD,0x25    /* ...s8..M..I....% */
  };




main(argc,argv)
int argc;
char **argv;
{
FILE *in,*out;
char outnamestub[32],*ptr;
int expect,tmp,p;
int pc,sp,sevenffd;

if(argc!=2) {usage(); exit(1);}

if((in=fopen(argv[1],"rb"))==NULL) die("Couldn't open file");

printf("Reading %s.\n",argv[1]);

if(fread(z80hed,1,Z80_V2_HEADER_SIZE,in)!=Z80_V2_HEADER_SIZE)
  die("Couldn't read Z80 header");

/* PC must be zero, or else this isn't a V2+ file */
if(z80hed[6] || z80hed[7]) die("Not a Z80 v2.x or v3.x file");

if(z80hed[12]==255) z80hed[12]=1;

/* check that length of 2nd header block is 23 or 54 */
if((z80hed[30]!=23 && z80hed[30]!=54) || z80hed[31]!=0 ||
   z80hed[34]<3) die("Not a 128K v2/v3 snapshot");

/* Z80 v3 messes around with the machine spec numbers (wow,
 * that was a sensible decision) so kludge around that here
 */
if(z80hed[30]==54 && z80hed[34]==3) die("Not a 128K v2/v3 snapshot");

/* ditch the extra stuff in the V3 header, which is useless to us anyway */ 
if(z80hed[30]==54) for(p=0;p<54-23;p++) fgetc(in);

/* read pages in */
for(p=0;p<8;p++)
  {
  /* number of (compressed) bytes to expect in the page */
  tmp=fgetc(in);
  expect=(fgetc(in)<<8)+tmp;
  if(fgetc(in)!=p+3) fprintf(stderr,"RAM page out of order...!");
  z80_unrle(in,specmem+PAGE_OFFSET(p),expect);
  }

fclose(in);


/* now convert the Z80 input to an MF3 file (well, files) */

/* work out a suitable output filename */

if((ptr=strrchr(argv[1],'/'))==NULL)
  strcpy(outnamestub,argv[1]);
else
  strcpy(outnamestub,ptr);

if((ptr=strrchr(outnamestub,'.'))!=NULL) *ptr=0;
outnamestub[7]=outnamestub[8]=0;

printf("Writing files %s and %sc.\n",outnamestub,outnamestub);

if((out=fopen(outnamestub,"wb"))==NULL) die("Couldn't open file");

outnamestub[strlen(outnamestub)+1]=0;
outnamestub[strlen(outnamestub)]='c';

for(tmp=0;tmp<9;tmp++) m3loader[0xE9+tmp]=32;

for(tmp=0;tmp<strlen(outnamestub);tmp++)
  m3loader[0xE9+tmp]=toupper(outnamestub[tmp]);

m3loader[0xE9+strlen(outnamestub)]=0xFF;

/* length of first data block - always 40781 + 0xD3 */
m3loader[0xF2]=(40781+0xD3)%256; m3loader[0xF3]=(40781+0xD3)/256;

m3loader[0x102]=0x71;	/* will be loading from disk */

/* put in sound chip values */
memcpy(m3loader+0x104,z80hed+39,16);

/* write the loader */
fwrite(m3loader,1,sizeof(m3loader),out);

fclose(out);


/* now write the actual data file */

if((out=fopen(outnamestub,"wb"))==NULL) die("Couldn't open file");

m3dathed[0]=0;
m3dathed[0x16]=0xB3; m3dathed[0x17]=0x60;

/* length of first data block inc. header - always 40781+0xD3 */
m3dathed[0x1A]=(40781+0xD3)%256; m3dathed[0x1B]=(40781+0xD3)/256;

/* length of second block - 0x1B00 */
m3dathed[0x1C]=0; m3dathed[0x1D]=0x1B;

m3dathed[0x1E]=m3dathed[0x1F]=0;

m3dathed[0x20]=4;	/* bit 2 - 128k format snapshot */

m3dathed[0x38]=0x0F;	/* RAM 1/3/4/6 included, none compressed */
m3dathed[0x39]=0x08;	/* RAM 7 included, not compressed */

/* RAM 1/3/4/6/7 all 16k long */
for(tmp=0;tmp<5;tmp++)
  {
  m3dathed[0x3A+tmp*2]=0;
  m3dathed[0x3B+tmp*2]=16384/256;
  }

/* fill in the registers (oh noooo) */

#define POKE16(x,y)	*(x)=(y)%256,*((x)+1)=(y)/256
#define PEEK16(x)	((*(x))+256*(*((x)+1)))

POKE16(m3dathed+0x4A,pc=PEEK16(z80hed+32));	/* PC */
POKE16(m3dathed+0x4C,PEEK16(z80hed+23));	/* IY */
POKE16(m3dathed+0x4E,PEEK16(z80hed+25));	/* IX */
POKE16(m3dathed+0x50,PEEK16(z80hed+15));	/* BC' */
POKE16(m3dathed+0x52,PEEK16(z80hed+17));	/* DE' */
POKE16(m3dathed+0x54,PEEK16(z80hed+19));	/* HL' */

/* AF and AF' are stored the other way around in Z80, weirddd */
m3dathed[0x56]=z80hed[22];			/* F' */
m3dathed[0x57]=z80hed[21];			/* A' */

POKE16(m3dathed+0x58,PEEK16(z80hed+ 2));	/* BC */
POKE16(m3dathed+0x5A,PEEK16(z80hed+13));	/* DE */

sevenffd=m3dathed[0x5C]=z80hed[35];		/* Mb (last OUT to 7FFDh) */
m3dathed[0x5D]=(z80hed[11]&127)+(z80hed[12]&1)*128;	/* R */

/* This is a 128/+2 snapshot, not +3, so we need to fake a value for
 * the low nibble of port 1FFDh, and add in the interrupt mode and
 * interrupts flag.
 * the faked value gives ROM 3 and disk motor off.
 */
tmp=4*16;
if((z80hed[29]&3)==2) tmp|=1;
if(z80hed[27]) tmp|=4;
m3dathed[0x5E]=tmp;				/* Mi */

m3dathed[0x5F]=z80hed[10];			/* I */

POKE16(m3dathed+0x60,PEEK16(z80hed+ 4));	/* HL */

/* AF and AF' are stored the other way around in Z80, weirddd */
m3dathed[0x62]=z80hed[ 1];			/* F */
m3dathed[0x63]=z80hed[ 0];			/* A */

/* push PC by hand. This is a pain in the rear end 'cos we have
 * to get the paging right. (sigh)
 * must check each byte separately as the word could cross a page
 * boundary. (well, I presume this is a possibility - I'd rather
 * not find out the hard way)
 */

sp=PEEK16(z80hed+8);

/* high byte */
sp--;
if(sp>49151) p=(sevenffd&7); else if(sp>32767) p=2; else p=5;
specmem[PAGE_OFFSET(p)+sp%16384]=pc/256;

/* low byte */
sp--;
if(sp>49151) p=(sevenffd&7); else if(sp>32767) p=2; else p=5;
specmem[PAGE_OFFSET(p)+sp%16384]=pc%256;

POKE16(m3dathed+0x64,sp);			/* SP */

#undef POKE16
#undef PEEK16


/* we're FINALLY ready to write the data header. */

fwrite(m3dathed,1,0xD3,out);

/* now write the uncompressed blocks for... */

/* 60B3h to FFFFh. This means the following blocks:
 * page 5, 20B3h to 3FFFh; page 2, 0000h to 3FFFh;
 * page 0, 0000h to 3FFFh.
 */
fwrite(specmem+PAGE_OFFSET(5)+0x20B3,1,0x4000-0x20B3,out);
fwrite(specmem+PAGE_OFFSET(2),1,0x4000,out);
fwrite(specmem,1,0x4000,out);

/* 4000h to 5AFFh (the screen). page 5, 0000h to 1AFFh. */
fwrite(specmem+PAGE_OFFSET(5),1,0x1B00,out);

/* 5B00h to 60B2h. page 5, 1B00h to 20B2h. */
fwrite(specmem+PAGE_OFFSET(5)+0x1B00,1,0x05B3,out);

/* now RAM pages 1/3/4/6/7 */
fwrite(specmem+PAGE_OFFSET(1),1,0x4000,out);
fwrite(specmem+PAGE_OFFSET(3),1,0x4000,out);
fwrite(specmem+PAGE_OFFSET(4),1,0x4000,out);
fwrite(specmem+PAGE_OFFSET(6),1,0x4000,out);
fwrite(specmem+PAGE_OFFSET(7),1,0x4000,out);

fclose(out);

printf("done.\n");

exit(0);
}


die(str)
char *str;
{
fprintf(stderr,"%s.\n",str);
exit(1);
}


usage()
{
printf("usage: z80tomf3 file.z80\n");
}


z80_unrle(in,outptr,expect)
FILE *in;
unsigned char *outptr;
int expect;
{
int f;
int b,oldb,count;

oldb=-1;
for(f=0;f<expect;f++)
  {
  b=fgetc(in);
  if(b==0xED && oldb==0xED)
    {
    outptr--;	/* compensate for first 0xED written in error */
    count=fgetc(in);
    b=fgetc(in);
    for(;count>0;count--) *outptr++=b;
    b=-1;
    f+=2;
    }
  else
    *outptr++=b;
  
  oldb=b;    
  }
}
